<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			/*
			 * filter()方法创建一个新数组，这个数组是满足函数逻辑判断的数组的子集。
			 * 语法：var newArray = arr.filter(callback(element[, index[, array]])[, thisArg])
			 * filter会为数组每一个元素调用一次callback函数
			 */
			/*
			 * 注意：filter 遍历的元素范围在第一次调用 callback 之前就已经确定了。在调用 filter 之后被添加到数组中的元素不会被 filter 遍历到。如果已经存在的元素被改变了，则他们传入 callback 的值是 filter 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。
			 * 	filter 不会改变原数组，它返回过滤后的新数组。
			 */
			var words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];
			var result = words.filter(word=>word.length > 6);
			console.log(result);
			
			//过滤JSON中的无效条目
			//以下示例使用 filter() 创建具有非零 id 的元素的 json。
			var arr = [
				  { id: 15 },
				  { id: -1 },
				  { id: 0 },
				  { id: 3 },
				  { id: 12.2 },
				  { },
				  { id: null },
				  { id: NaN },
				  { id: 'undefined' }
				];
			function isNumber(obj){
				return obj !== undefined && typeof(obj) === 'number' && !isNaN(obj);
			}
			var invalidEntries = 0;
			var arrByID = arr.filter(function filterByID(item){
				if (isNumber(item.id) && item.id !== 0) {
				    return true;
				  } 
				  invalidEntries++;
				  return false; 
			})
			console.log('Filtered Array\n', arrByID); 
			console.log('Number of Invalid Entries = ', invalidEntries); 
			
			//在数组中搜索
			var fruits = ['apple', 'banana', 'grapes', 'mango', 'orange'];
			function filterItems(query){
				return fruits.filter(function(el){
					return el.toLowerCase().indexOf(query.toLowerCase()) > -1;
				})
			}
			console.log(filterItems('ap'));
		</script>
	</body>
</html>
