<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
	</head>
	<body>
		
	</body>
	<script type="text/javascript">
		/*
		 * arr.reduce(callback(accumulator, currentValue, index, array), initialValue)
		 * 参数：
		 * 		callback():
		 * 				参数：
		 * 					accumulator:第一次的值有两种情况；以后的值就是上一次调用回调时返回的累积值
		 * 					currentValue：第一次的值有两种情况；以后就是数组的下一位值
		 * 					currentIndex：下标
		 * 					array：数组
		 * 		initialValue:
		 * 注意:
		 * 	accumulator 和currentValue的取值有两种情况：如果调用reduce()时提供了initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；如果没有提供 initialValue，那么accumulator取数组中的第一个值，currentValue取数组中的第二个值。
		 */
		
		//累加对象数组里的值
		var sum = [{x: 1}, {x:2}, {x:3}].reduce(function (acc, cur){return acc + cur.x;}, 0)
		console.log(sum);
		/*箭头函数表示
		var sum = [{x: 1}, {x:2}, {x:3}].reduce((acc, cur)=>acc + cur.x, 0)
		*/
		
		//二维数组转换为一维数组
		var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(acc, cur){return acc.concat(cur);}, []);
		
		//计算数组中每个元素出现的次数
		var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];
		var countName = names.reduce(function(allNames, name){
			if (name in allNames) {
				allNames[name]++;
			} else{
				allNames[name] = 1;
			}
			return allNames;
		}, {});
		console.log(countName);
		console.log(Array.isArray(countName));
		
		//按属性对object分类
		var people = [
		  { name: 'Alice', age: 21 },
		  { name: 'Max', age: 20 },
		  { name: 'Jane', age: 20 }
		];
		function groupBy(objectArray, property){
			return objectArray.reduce(function(acc, obj){
				var key = obj[property];
				if(!acc[key]){
					acc[key] = [];
				}
				acc[key].push(obj);
				return acc;
			},{});
		}
		var groupPeople = groupBy(people, 'age');
		console.log(groupPeople);
		
		//使用扩展运算符和initialValue绑定包含在对象数组中的数组
		var friends=[
			{
				name: 'Anna',
				books: ['Bible', 'Harry Potter'],
				age: 21
			},
			
			{
				name: 'Bob',
				books: ['War and peace', 'Romeo and Juliet'],
				age: 26
			},
			{
				name: 'Alice',
				books: ['The Lord of the Rings', 'The Shining'],
				age: 18
			}];
			var allbooks = friends.reduce(function(prev, curr){
				return [...prev, ...curr.books];
			}, ['Alphabet']);
			console.log(allbooks);
			
			//数组去重
			var arr = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd'];
			var orderArr = arr.reduce(function(acc, cur){
				if (acc.indexOf(cur) === -1) {//indexOf()返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1
					acc.push(cur);
				}
				return acc
			},[])
			console.log(orderArr);
			
			//reduce实现map()
			if (!Array.prototype.mapUsingReduce) {
				Array.prototype.mapUsingReduce = function(callback, thisArg){
					return this.reduce(function(mappedArray, currentValue, index, array){
						mappedArray[index] = callback.call(thisArg, currentValue, index, array);
						return mappedArray;
					},[])
				};
			}
			[1, 2, 3].mapUsingReduce((currentValue, index, array)=>{
				console.log(currentValue + index + array.length);
				currentValue + index + array.length
			});
			
			//reduceRight()的工作原理和reduce()一样的。只是它是从右向左遍历。
	</script>
</html>
